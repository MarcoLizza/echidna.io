---
title: 'devlog #8'
author: marco.lizza
layout: post
permalink: "/devlog-8/"
comments: true
categories: 
  - devlog
tags: 
  - indiedev
  - gamedev
  - game-design
  - 30daydev
---
# Prologue

Ready for another [#30daydev](https://itch.io/jam/30daydev) round. So far, in the previous 30 days, I managed to (almost) complete the simple pixel-art for the game. I've been studying the game internals and I began designing the game structure accordingly. The current code-base is voluntarily kept at the bare minimum, with no over-engineering.

Within the end of this round, I aim to complete the game AI, leaving the final touches for the next month.

## Day #1 (2018-05-12)

Worked on two very important parts of the game, that is the **actors management system** and the **animation manager**. Both have been implemented as generic as possible, in order to be pretty much reusable in future projects.

The interesting part for the **AMS** module is the adoption of a deferred spawn/kill policy. That is, when a new actor is to be added/ removed from the set, it is at first stored in a table. Later, during the updating step, the actor is moved from/to the active actors' list (an optional event callback is called for the actor to perform additional operations). The list is, then, sorted by priority  eventually draw the actors with the proper z-order. Perhaps, I'll be revising this in the near future in favour of a more versatile and generic method.

For the animation module, the interesting part is how the animation modes are implemented. With a scripting language such as Lua once can use closures and functions as first-class-citizens to implement an iterator(s) capable of handling different cases in a smart way, keeping the main module readable.

```lua
-- `t` is the frames' index table, that traces the drawing order.
-- `mode` is a string value indicating the animation mode.
local function iterator(t, mode)
  local i = 0
  local n = table.getn(t)
  local d = 1
  if mode == 'loop' then
    return function()
        i = i + 1
        if i == n + 1 then
          i = 1
        end
        return t[i]
      end
  elseif mode == 'bounce' then
    return function()
        i = i + d
        if (d > 0 and i == n) or (d < 0 and i == 1) then
          d = -d
        end
        return t[i]
      end
  elseif mode == 'once' then
    return function()
        i = i + 1
        if i == n + 1 then
          return nil
        end
        return t[i]
      end
  end
end
```

## Day #2/#3 (2018-05-13/14)

I'm definitely fallen into a *closure rage*. In the last two days, I've been implementing some utility modules (animation, typewriting, and tweening among the others) only to found that in each of them using closures really simplify the code. It is somewhat more difficult to follow at first, since some parts of the logic are decoupled, but they end up being far more polished than a plain imperative/procedural approach.

There's a popular saying to explain what closures are which depicts them as poor's man objects (and vice-versa). This is pretty accurate, as far as we only examine their usage to encapsulate data and functionality in a single logical unit. The enable to define a proper lexical scope and help in keeping things separated. None is better than the other and usage of one over the other need to be carefully weighed.

> Of course, I'm not acknowledging the memory footprint of the case. From this point of view, an imperative approach is more considerate and conservative.
---
title: 'devlog #2'
author: marco.lizza
layout: post
permalink: "/devlog-2/"
comments: true
published: false
categories: 
  - devlog
tags: 
  - indiedev
  - gamedev
  - shaders
  - copper
  - visual-effects
---
My plan to post weekly devlog entries seems to have gone awry. Althought I keep tracking my daily thoughts/activities, the process of collecting and organizing them is cumbersome. Also, since I'm still in a somewhat *brainstorm phase* of the projects, the things I write one day can be nonesense the day after. Let's see if I can improve in the future.

In this entry I'd like to talk a bit about **shaders**.

Shaders are everywhere and for a reason. With a handful of instructions one can easily implement some nice visual effects without heavily burdening the CPU.

It seems that 2D water shaders are among the most popular ones. Almost everybody seems to be interested in developing and/or using them in their games.

Me included, or at least that's what I thought at the beginning. In fact, originally in this entry I wanted to present in greater detail an *awesome* fragment-shader, implementing a cute bi-dimensional reflection effect.

Personally, I've been fascinated by *shaders* since the mid nineties when I installed my first GPU-boosted card on my Pentium computer. I liked them from the beginning because, in my opinion, they carry along with them the marvel and the charm of the old-school effects we were used to marvel upon during the Commodore days (and I miss them sooo much!). The concept itself of shader is intimately close to the *copper-list*(1): a sequence of instructions executed in parallel from the CPU by a dedicate chip.

Starting from this premise, I decided to change my mind a bit. I won't be using fragment-shaders just  to properly and nicely edulcorate the visual appeal of the game (of course I will use them for such purpose). Most of all, I'll try and exploit them to simulate the kind of effects that the Copper chip did back in the days.

For example, one very nice usage of a fragment shader is to render copper-bars! ;)

```hlsl
// Basic colors.
const vec4 BRIGHT_RED = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 BRIGHT_YELLOW = vec4(1.0, 1.0, 0.0, 1.0);
const vec4 BRIGHT_GREEN = vec4(0.0, 1.0, 0.0, 1.0);
const vec4 BRIGHT_CYAN = vec4(0.0, 1.0, 1.0, 1.0);
const vec4 BRIGHT_BLUE = vec4(0.0, 0.0, 1.0, 1.0);
const vec4 BRIGHT_PURPLE = vec4(1.0, 0.0, 1.0, 1.0);
const vec4 RED = vec4(0.8, 0.0, 0.0, 1.0);
const vec4 YELLOW = vec4(0.8, 0.8, 0.0, 1.0);
const vec4 GREEN = vec4(0.0, 0.8, 0.0, 1.0);
const vec4 CYAN = vec4(0.0, 0.8, 0.8, 1.0);
const vec4 BLUE = vec4(0.0, 0.0, 0.8, 1.0);
const vec4 PURPLE = vec4(0.8, 0.0, 0.8, 1.0);
const vec4 DARK_RED = vec4(0.4, 0.0, 0.0, 1.0);
const vec4 DARK_YELLOW = vec4(0.4, 0.4, 0.0, 1.0);
const vec4 DARK_GREEN = vec4(0.0, 0.4, 0.0, 1.0);
const vec4 DARK_CYAN = vec4(0.0, 0.4, 0.4, 1.0);
const vec4 DARK_BLUE = vec4(0.0, 0.0, 0.4, 1.0);
const vec4 DARK_PURPLE = vec4(0.4, 0.0, 0.4, 1.0);
const vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);
const vec4 BRIGHT_GRAY = vec4(0.8, 0.8, 0.8, 1.0);
const vec4 DARK_GRAY = vec4(0.4, 0.4, 0.4, 1.0);
const vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);

// Shader parameters, you would probably define them as "uniform".
const float FREQUENCY_MULTIPIER = 5.0;
const float AMPLITUDE_MULTIPIER = 0.25;
const float BASE_POSITION = 0.5;
const float HEIGHT = 0.0500;

// Computes the copperbar colors for the [uv] pixel.
vec4 copperbar(in vec2 uv,
               in float base, in float frequency, in float amplitude,
               in vec4 innerColor, in vec4 outerColor)
{
    float alpha = iGlobalTime * frequency; // Scale current time according to copperbar frequency.
    float position = base + (sin(alpha) * amplitude); // Get the copperbar middle position.
    float ratio = abs(uv.y - position) / HEIGHT; // Normalized (to height) distance.
    if (ratio > 1.0) { // Pixel is beyond copperbar limit, set to black.
        return BLACK;
    }
    return mix(innerColor, outerColor, ratio); // Mix to generate a gradient.
}

// Picks the first non-black color in the array.
vec4 choose(in vec4[3] colors)
{
    for (int i = 0; i < colors.length(); ++i) {
        vec4 color = colors[i];
        if (color != BLACK) {
            return color;
        }
    }
    return BLACK;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
	vec2 uv = fragCoord.xy / iResolution.xy;
	fragColor = choose(vec4[](
        copperbar(uv, BASE_POSITION, FREQUENCY_MULTIPIER * 0.9, AMPLITUDE_MULTIPIER, BRIGHT_CYAN, DARK_BLUE),
        copperbar(uv, BASE_POSITION, FREQUENCY_MULTIPIER, AMPLITUDE_MULTIPIER, BRIGHT_YELLOW, DARK_RED),
        copperbar(uv, BASE_POSITION, FREQUENCY_MULTIPIER * 1.1, AMPLITUDE_MULTIPIER, BRIGHT_YELLOW, DARK_GREEN)
    ));
}
```

Thanks to [ShaderToy](https://www.shadertoy.com/view/MsfBz4), you can see this simple shader in action! ;)

{% raw %}
<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/MsfBz4?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
{% endraw %}

*( See you next time! )*
---

*<sup><a name="copperlist_note">1</a></sup> To be precise, copper-list are much more power*
